daemon  off;
user www-data;

pid         logs/nginx.pid;
error_log   logs/nginx-main_error.log debug;

worker_rlimit_core  500M;
working_directory /tmp;

worker_processes 2;

env REDIS_PORT_6379_TCP_ADDR;
env REDIS_PORT_6379_TCP_PORT;

events {
	worker_connections 1024;
}

http {
	access_log      logs/nginx-http_access.log;


	tcp_nopush                  on;
	tcp_nodelay                 on;
	keepalive_timeout           10;
	send_timeout                10;
	client_body_timeout         10;
	client_header_timeout       10;
	sendfile                    on;
	client_header_buffer_size   1k;
	large_client_header_buffers 1 2k;
	client_max_body_size        1k;
	client_body_buffer_size     1k;
	ignore_invalid_headers      on;

	push_stream_shared_memory_size 100m;
	push_stream_max_channel_id_length 200;
	push_stream_max_messages_stored_per_channel 20;
	push_stream_message_ttl 5m;
	push_stream_subscriber_connection_ttl 15m;
	push_stream_longpolling_connection_ttl 30s;

	lua_package_path "/lua-modules/lua-resty-redis/lib/resty/?.lua;;";

	server {
		listen 80 default_server;

		location /channels-stats {
			push_stream_channels_statistics;
			push_stream_channels_path $arg_id;
		}

		location /pub {
			push_stream_publisher admin;
			push_stream_channels_path $arg_id;
			push_stream_store_messages off;
			client_max_body_size 4000k;
			client_body_buffer_size 4000k;
		}

		location ~ /sub/(.*) {
			push_stream_subscriber;
			push_stream_channels_path $1;
			push_stream_message_template "Content-Type: image/jpg\n\n~text~\n--endofsection";
			default_type "multipart/x-mixed-replace; boundary=endofsection";
		}

		location ~ /ws/(.*) {
			push_stream_subscriber websocket;
			push_stream_channels_path $1;
			push_stream_message_template "~text~";
		}

		location ~/snapshot/(.*) {
			set $channel $1;
			set $timestamp $arg_timestamp;
			set $utc_timestamp $arg_utc;

			content_by_lua '
				local totimestamp = function(str_time)
					local pattern = "(%d+)%-(%d+)%-(%d+) (%d+):(%d+):(%d+)"
					local year, month, day, hour, minute, seconds = string.match(str_time, pattern)
					return os.time({year=year,month=month,day=day,hour=hour,min=minute,sec=seconds})
				end
				local utcdelta = totimestamp(ngx.utctime()) - totimestamp(ngx.localtime())

				local redis = require("redis")
				local red = redis:new()
				assert(red:connect(os.getenv("REDIS_PORT_6379_TCP_ADDR"), os.getenv("REDIS_PORT_6379_TCP_PORT")))

				local channel = "thumb/" .. ngx.var.channel
				local utctimestamp = 0
				local keys
				if ngx.var.timestamp ~= "" then
					utctimestamp = tonumber(ngx.var.timestamp) + utcdelta
				elseif ngx.var.utc_timestamp ~= "" then
					utctimestamp = tonumber(ngx.var.utc_timestamp)
				end
				if utctimestamp > 0 then
					keys = assert(red:zrangebyscore(channel, utctimestamp, "+inf", "LIMIT", "0", "1"))
				else
					keys = assert(red:zrevrangebyscore(channel, "+inf", "-inf", "LIMIT", "0", "1"))
				end
				if #keys == 0 then
					return ngx.exit(ngx.HTTP_NOT_FOUND)
				end
				local key = keys[1]
				local imagedata = assert(red:get(key))
				ngx.header.content_type = "image/jpeg"
				if imagedata == nil then
					return ngx.exit(ngx.HTTP_NOT_FOUND)
				end
				ngx.print(imagedata)
			';
		}
	}
}
